package edu.carroll.EatAndShare.backEnd.model;

import java.util.List;
import java.util.Objects;

import jakarta.persistence.*;

/**
 * This Object represents a user within the EatAndShare application.
 * Each User can own multiple Recipe entities.
 *
 * <p>This class is annotated as a JPA entity and maps to the "user" table
 * in the database. It stores user credentials and basic profile
 * information, including username, password, and contact details.
 *
 * <p>Relationships:
 * <ul>
 *   <li>One-to-Many with {@link Recipe} â€“ each user can have multiple recipes.</li>
 * </ul>
 *
 * <p>Implements helper methods for displaying user info, equality comparison,
 * and hash generation. Passwords are never shown in plain text within the
 * {@code toString()} method.</p>
 *
 * @author Andrias
 * @version 1.0
 */
@Entity
@Table(name = "user")
public class User {
    /** Serialization identifier (best practice for entity classes). */
    private static final long serialVersionUID = 1L;

    /** Primary key for the User entity. Automatically generated by the database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Integer id;

    /** Unique username associated with this user. */
    @Column(name = "username", nullable = false, unique = true)
    private String username;

    /** Password (should be stored as a hashed string). */
    @Column(name = "password", nullable = false)
    private String password;

    /** User's email address, used for account recovery and contact. */
    @Column(name = "email", nullable = false)
    private String email;

    /** User's first name. */
    @Column(name = "first_name", nullable = false)
    private String firstName;

    /** User's last name. */
    @Column(name = "last_name", nullable = false)
    private String lastName;

    /**
     * One-to-many relationship with Recipe.
     * Each user may own multiple recipes.
     * Cascade ensures that related recipes are persisted and deleted
     * along with the user.
     * Orphan removal deletes recipes not associated with any user.
     */
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Recipe> recipes;

    /** @return the user's first name */
    public String getFirstName() {
        return firstName;
    }

    /** @param firstName sets the user's first name */
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    /** @return the user's last name */
    public String getLastName() {
        return lastName;
    }

    /** @param lastName sets the user's last name */
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    /** @return the unique user ID */
    public Integer getId() {
        return id;
    }

    /** @param id sets the user ID (auto-generated by the database) */
    public void setId(Integer id) {
        this.id = id;
    }

    /** @return the username */
    public String getUsername() {
        return username;
    }

    /** @param username sets the username */
    public void setUsername(String username) {
        this.username = username;
    }

    /** @return the user's password (stored as hashed text) */
    public String getPassword() {
        return password;
    }

    /** @param password sets the user's password (should be hashed before storage) */
    public void setPassword(String password) {
        this.password = password;
    }

    /** @return the user's email address */
    public String getEmail() {
        return email;
    }

    /** @param email sets the user's email address */
    public void setEmail(String email) {
        this.email = email;
    }

    /** End-of-line constant used for formatting the {@code toString()} output. */
    private static final String EOL = System.lineSeparator();

    /** Tab constant for indentation within {@code toString()}. */
    private static final String TAB = "\t";

    /**
     * Returns a formatted string representation of the user object.
     * Password is masked for security.
     *
     * @return a readable string representing this User object
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Login @ ").append(super.toString()).append("[").append(EOL);
        builder.append(TAB).append("username=").append(username).append(EOL);
        builder.append(TAB).append("hashedPassword=").append("****").append(EOL);
        builder.append(TAB).append("email=").append(email).append(EOL);
        builder.append("]").append(EOL);
        return builder.toString();
    }

    /**
     * Compares two User objects based on their username and password.
     * Typically, equality is defined by username alone, but here both
     * fields are considered.
     *
     * @param o the object to compare with
     * @return true if both objects have the same username and password
     */
    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        final User user = (User) o;
        return username.equals(user.username) && password.equals(user.password);
    }
}
